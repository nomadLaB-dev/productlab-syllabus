---
title: "第4.5回：React直前！モダンJS/TS解読筋トレ"
---

import { Steps, Aside, Card, CardGrid } from '@astrojs/starlight/components';

## 🌟 今日の目的
Reactという高度な道具を扱う前に、エンジニア同士（そしてAI）との共通言語をマスターします。
「なんとなく動く」を卒業し、コードが「何をしようとしているのか」を読み解く筋肉を鍛えましょう！

---

## 🛠️ コードを自分の手で動かす準備

今日学ぶ「共通言語」は、実際に自分のPCで動かすことで 10 倍速く身につきます。
おすすめの実験方法を以下で説明します。

### ⚡ ターミナルでサクッと動かしてみよう！

<Steps>
1.  **ファイルを作る**
    VS Code で `practice.ts` というファイルを新規作成します。
2.  **コードを貼る**
    講義のコードを貼り付けて保存（`Ctrl + S`）します。
3.  **コマンドを打つ**
    ターミナルで以下の呪文を打ちます。
    ```bash
    npx tsx practice.ts
    ```
</Steps>

<Aside type="tip" title="なぜこれがいいの？">
  ブラウザを使わずに結果が見れるので、ロジックだけに集中できます。プロはこの方法で「ちょっとした動作確認」をよくやるよ！
</Aside>

---

## 1. オブジェクト（Object）：データと動きのパッケージ

オブジェクトは、関連するデータと動きを一つにまとめた「モノ」です。



```typescript
const smartphone = {
  // プロパティ（属性）：状態を表すデータ
  brand: "Apple",
  battery: 85,

  // メソッド（動き）：そのモノができる動作（関数）
  touchScreen: () => {
    console.log("画面がタップされました！");
  }
};

console.log(smartphone.brand); // 属性を取り出す
smartphone.touchScreen();      // 動きを実行する
```

<Aside type="tip" title="なぜオブジェクトにするの？"> 
バラバラの変数（brand1, brand2...）で管理するより、一つの塊（smartphone）にする方が、「スマホに関するデータなんだな」と人間にもAIにも分かりやすくなるからです。 
</Aside>

---

## 2. 関数（Function）と引数（Argument）：再利用できるレシピ
関数は「一連の手順をまとめたレシピ」です。

### 🍳 レシピを構成する3つの要素
1. 関数名: レシピの名前（例：makeCurry）
2. 引数（ひきすう）: 料理に使う「材料」。外から渡すデータ。
3. 戻り値（返り値）: 出来上がった「料理」。処理した結果。

```typescript
// 簡単な例
// (材料1, 材料2) => { レシピの中身 }
const addNumbers = (a: number, b: number) => {
  return a + b; // 結果を「戻す」
};

const result = addNumbers(5, 3); // 5と3を「引数」として渡す
```


```typescript
// 関数名: makeCurry
// 引数（材料）: meat（肉）, veggies（野菜の配列）
const makeCurry = (meat: string, veggies: string[]) => {
  console.log("--- 調理開始！ ---");
  console.log(`${meat}を炒めます...`);
  console.log(`${veggies.join("と")}を煮込みます...`);
  
  // 戻り値（完成した料理）
  return `${meat}と${veggies.length}種類の野菜が入った、特製カレー`;
};

// --- 関数を「呼び出す（実行する）」 ---
// 引数（材料）を渡して、出来上がりを「myDinner」という変数（皿）で受け取る
const myDinner = makeCurry("牛肉", ["じゃがいも", "にんじん", "たまねぎ"]);

console.log(`今夜のメニューは、${myDinner}です！🍛`);
```

<Aside type="note"> 
エンジニアの会話では「この関数の第一引数（一個目の材料）にユーザーIDを渡して」といった言い方をします。これが私たちの共通言語です！ 
</Aside>

### 🏹 アロー関数（現代の書き方）
プログラミングの世界でも、より「短く、間違いにくく」書くために書き方の進化が起きました。
「昔の分厚いレシピ本」と「今どきのスマートなレシピメモ」の違いを見てみましょう。
最近のエンジニアは、function という文字をあまり書きません。代わりに =>（矢印） を使った「アロー関数」を使います。

| 特徴 | 昔の書き方 (`function`) | 今の書き方 (アロー関数 `=>`) |
| :--- | :--- | :--- |
| **イメージ** | どっしりした「レシピ本」 | スマートな「レシピメモ」 |
| **記述量** | `function` と書くのが長い | `=>`（矢印）だけでOK！ |
| **戻り値** | 必ず `{ return ... }` が必要 | 1行なら `{}` も `return` も省略可 |
| **安全性** | 「誰が料理してるか」を見失う時がある | 周りの状況を正しく理解してくれる |


``` bash
 - 昔の書き方: function(a) { ... }
 - 今の書き方: (a) => { ... }
```

<Aside type="tip"> 
見た目がスッキリするだけでなく、Reactのプログラムを書く時に「予期せぬエラー」が起きにくいというメリットがあります。 
</Aside>

### 💻 実際に比較してみよう
同じ「カレーを作る」指示でも、これだけ見た目が変わります。

```typescript

// 1. 昔の書き方（function）
// 「これから関数を作りますよ！」という重厚な宣言が必要
function oldMakeCurry(meat: string) {
  return meat + "カレー";
}

// 2. 今の書き方（アロー関数）
// 「矢印（=>）」が「作る」という意味。変数（箱）にレシピを入れる感覚
const newMakeCurry = (meat: string) => meat + "カレー";
```

#### ✅ メリット・デメリット

* **メリット（ここが使いやすい！）**
    * **とにかく短い！**: コードがスッキリして、パッと見て何をしているか分かりやすくなります。
    * **1行で書ける**: 処理が短いときは、数学の公式のように1行で完結できます。
    * **Reactと相性抜群**: Reactのルール（Hooksなど）ではこの書き方が前提なので、今の開発の標準です。

* **デメリット（ここに注意！）**
    * **最初は戸惑う**: `=>` という記号が「関数」だと脳が認識するまで、少し慣れが必要です。
    * **名前がないことがある**: `() => { ... }` と名前をつけずに使う（無名関数）ことも多いため、後からエラーを探すときに少し工夫が必要です。

<Aside type="tip" title="結論：どっちを覚える？"> 
  アロー関数だけを完璧に使いこなせればOKです！ 古いプロジェクトをメンテナンスする時以外、自分から function を使う機会はほとんどありません。AIが出してくるコードも、現代のプロが書くコードも、ほぼ100%アロー関数です。 
</Aside>

### 🤙 コールバック関数：あとで実行する「予約」
関数の中に、別の関数を「材料（引数）」として渡すことがあります。これを コールバック関数 と呼びます。

#### 🤔 なぜわざわざ「関数」を渡すの？（理由）
「料理を作る」という共通の手順は変えずに、 **「作った後に何をするか」だけを自由に変えたい** からです。 もしコールバックを使わないと、「カレーを作って洗う関数」「カレーを作って食べる関数」…と、似たような関数を何個も作る羽目になります。

#### 🕹️ どんな時に使うの？（シーン）
Reactの世界では、主に以下の3つのシーンで登場します。

1. **イベント（何かが起きた時）**: 「ボタンが **クリックされた時** に、この関数を動かして！」
2. **タイマー（時間が経った時）**: 「**3秒経ったら** 、このメッセージを消して！」
3. **配列の処理（データの数だけ）**: 「 **リストの1個ずつに対して** 、このHTMLを作って！」

```typescript
// --- 1. カレー作りの例（後片付けを自由に選べる） ---
const makeCurry = (meat: string, afterCook: () => void) => {
  console.log(`${meat}カレーが完成！🍛`);
  afterCook(); // 渡された「予約」を実行
};

// シーンA：食べてから寝たい時
makeCurry("牛肉", () => console.log("食べて寝る！💤"));

// シーンB：誰かにプレゼントしたい時
makeCurry("鶏肉", () => console.log("友達に届ける！🎁"));

// --- 2. Reactでよく見る「クリック」の例 ---
// ボタンを押した時（イベント）に動かしてほしい関数を「予約」として渡す
<button onClick={() => console.log("ボタンが押されたよ！")}>送信</button>
```

---

## 3. 非同期処理（async / await）：待ち時間の作法
Webアプリでは「データの到着を待つ」時間が頻繁に発生します。これを「非同期処理」と呼びます。

 - async: 「この関数の中には、待ち時間が発生する処理があるよ」という宣言。
 - await: 「データが届くまで、ここでちょっと待ってて！」という命令。
<Aside type="danger" title="解読筋トレ：間違い探し①"> 
次のコードは、なぜ こんにちは、[object Promise]さん と表示されてしまうのでしょう？

```typescript
const fetchUser = async () => "貞末 麗斗";

const showMessage = () => {
  const name = fetchUser(); // 🚨 ここ！
  console.log(`こんにちは、${name}さん`);
};
```
**答え** : fetchUser は「未来に結果を返す約束（Promise）」を返しているから。await を使って「約束が果たされる（データが届く）」のを待つ必要があります。

</Aside>

---

## 4. モダンJS/TS：AIコードの急所を見抜く

### 分割代入（Destructuring）
Reactで最もよく使う「データの取り出し方」です。

``` typescript
const user = { name: "麗斗", age: 30, role: "VPoE" };

// 昔：一つずつ取り出す
// const name = user.name;

// 今：一気に取り出す！
const { name, role } = user;

console.log(name); // "麗斗"
```

### 🔍間違い探し②：オブジェクトと配列の混同

```typescript

const family = {
  members: ["夫", "妻", "息子"],
  rabbit: { name: "なぎ", color: "チェスナット" }
};

// 🚨 エラー：family.members.name
// 答え：membersは「配列」なので .name はありません。
// family.rabbit.name ならOK！
```
### 🔍 間違い探し③：mapメソッドの「お返し」忘れ
```typescript

const list = ["HTML", "CSS", "TS"].map((item) => {
  `<li>${item}</li>`; // 🚨 画面に何も出ない！
});
// 答え：{} を使った時は、必ず「return」で結果を返さないといけません。
```

---

## 🚀 今週の宿題：JSの「体幹」を鍛える
来週からのReact編をスムーズに進めるために、ProgateでJavaScriptの基本を復習・予習しておきましょう！

1. Progate JavaScript（ES6）コース
 - JavaScript 基礎編 を終わらせよう。
 - JavaScript 応用編 （特にオブジェクト、配列の操作、map/filterなどの繰り返し処理）を重点的にやってみよう。 （https://prog-8.com/languages/javascript）

2. AIへの挑戦状
AI（Geminiなど）にこう聞いてみてください。 「JavaScriptの『分割代入』と『スプレッド構文』について、初心者にわかりやすく猫でもわかる例えで教えて！」

<Aside type="tip" title="ノマドLaBの掟"> 
文法をすべて暗記する必要はありません。「こういう便利な書き方があるんだな」と知っておくだけで、AIの出す回答が10倍読みやすくなるよ！ 
</Aside>